/**
 *----------------------------------------------
 * Author: lenon
 * Create Time: 2016/3/2 10:41
 * Desc: (工具类)
 * Changed list:
 *        Change author:(若修改请指明修改者)
 *        Change desc:(修改描叙)
 *        Change time:(修改的时间)
 *----------------------------------------------
 **/
var CountDownLatch = require('./countDownLatch');

var utils = module.exports;

/**
 * 执行某回调函数
 * @param callback      被执行的回调函数
 */
utils.invokeCallback = function(callback) {
    if ( !! callback && typeof callback === 'function') {
        callback.apply(null, Array.prototype.slice.call(arguments, 1));
    }
};

/**
 * 生成指定长度的数字
 * @param x             指定长度，未指定默认为1;
 * @returns {number}    指定长度的数字
 */
utils.randomNumber = function(x) {
    if (!x) x = 1;
    var y = '';
    for (var i = 0; i < x; ++i) {
        y += Math.floor(Math.random() * 10);
    }
    return Number(y);
};

/**
 * 顺序执行对象数组中的指定函数
 * @param arr       对象数组
 * @param method    指定函数名
 * @param args      参数数组
 */
utils.opt = function(arr, method, args){
    for(var i= 0, j = arr.length; i < j; ++i){
        if (!arr[i]) continue;
        var fun = arr[i][method];
        if (!fun || typeof fun !== 'function') continue;
        fun.apply(arr[i], args);
    }
};

/**
 * 执行对象数组中，带有回调的函数
 * @param arr       对象数组
 * @param method    指定函数名
 * @param args      参数数组
 */
utils.parallelOpt = function(arr, method, args){
    var next = args.pop();
    if (arr.length <= 0) {
        utils.invokeCallback(next, null, null);
        return;
    }

    var latch = CountDownLatch.createCountDownLatch(arr.length, function(err){
        utils.invokeCallback(next, err, null);
    });

    function callback(err){
        if(!!err) {
            throw err;
        }
        latch.done();
    }

    args.push(callback.bind(null));

    for(var i=0, l=arr.length; i<l; i++) {
        if (!arr[i]) continue;
        var fun = arr[i][method];

        if (!!fun && typeof fun === 'function') {
            try{
                fun.apply(arr[i], args);
            } catch(e){
                utils.invokeCallback(next, e, null);
                return;
            }
        } else {
            latch.done();
        }
    }
};