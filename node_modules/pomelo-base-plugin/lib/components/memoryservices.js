/**
 *----------------------------------------------
 * Author: lenon
 * Create Time: 2016/3/2 11:35
 * Desc: (这里写描叙)
 * Changed list:
 *        Change author:(若修改请指明修改者)
 *        Change desc:(修改描叙)
 *        Change time:(修改的时间)
 *----------------------------------------------
 **/
var sysConst = require('./../const/sysConst');
var utils = require('./../utils/utils');
var memwatch = require('memwatch');
var logger = require('pomelo-logger').getLogger('pomelo', __filename);
var util = require('util');

// 基础服务
module.exports = function (app, opts) {
    return new Component(app, opts);
};

var Component = function (app, opts) {
    this.app = app;
    this.open = opts.open || sysConst.DEFAULT_SETTINGS.MEMORY_WATCH_STATUS;
    this.intervalTime = opts.intervalTime || sysConst.DEFAULT_SETTINGS.MEMORY_GC_INTERVAL;
};

var pro = Component.prototype;

pro.name = '__memservices__';

var format = function(bytes){
    var num = bytes / 1024 / 1024.0;
    if (num > 1024){
        return (num / 1024).toFixed(2) + 'GB';
    } else {
        return num.toFixed(2) + 'MB';
    }
};

pro.start = function (next) {
    // 指定关闭，或者在产品模式下，内存监控为关闭状态;
    if (!this.open || this.app.get('env') === 'production'){
        utils.invokeCallback(next);
        return;
    }
    var ch = process.platform === 'win32';
    var self = this;
    // 5次垃圾回收，内存没有被释放，则会触发leak事件;
    memwatch.on('leak', function(info){
        if (!info) return;
        var mem = process.memoryUsage();
        logger.warn(
            (ch ? ('\n=============内存增长情况=============\n')
                : ('\n=========the memory growth=========\n')) +
            self.app.getServerId() + '\n' +
            (ch ? ('开始时间:[ %s ]\n')
                : ('the start time:[ %s ]\n')) +
            (ch ? ('结束时间:[ %s ]\n')
                : ('the end time:[ %s \n')) +
            (ch ? ('原因:[ %s ]\n')
                : ('the reason:[ %s ].\n')) +
            (ch ? ('增长:[ %s ]\n')
                : ('growth size::[ %s ]\n')) +
            (ch ? ('常驻内存:[ %s ]\n')
                : ('the resident set size:[ %s ].\n')) +
            (ch ? ('堆中共申请的内存:[ %s ]\n')
                : ('the heap total size:[ %s ].\n')) +
            (ch ? ('堆中使用的内存:[ %s ]\n')
                : ('the heap used size:[ %s ].\n')) +
            '======================================'
            ,

            info.start,
            info.end,
            info.reason,
            format(info.growth),
            format(mem.rss),
            format(mem.heapTotal),
            format(mem.heapUsed)
        );
    });

    // 每次进行全堆垃圾回收，会触发一次stats事件;
    memwatch.on('stats', function(stats){
        if (!stats) return;
        var mem = process.memoryUsage();

        logger.info(
            (ch ? ('\n=============当前内存状态=============\n')
                : ('\n=========current memory stats=========\n')) +
            self.app.getServerId() + '\n' +
            (ch ? ('第[ %s ]次全堆垃圾回收\n')
                : ('the [ %s ] times all heap gc.\n')) +
            (ch ? ('第[ %s ]次增量垃圾回收\n')
                : ('the [ %s ] times inc gc.\n')) +
            (ch ? ('第[ %s ]次老生代内存压缩整理碎片\n')
                : ('the [ %s ] times old generation heap compactions.\n')) +
                //(ch ? ('当前的内存基数:[ %s ]\n')
                //    : ('the current base:[ %s ].\n')) +
            (ch ? ('常驻内存:[ %s ]\n')
                : ('the resident set size:[ %s ].\n')) +
            (ch ? ('堆中共申请的内存:[ %s ]\n')
                : ('the heap total size:[ %s ].\n')) +
            (ch ? ('堆中使用的内存:[ %s ]\n')
                : ('the heap used size:[ %s ].\n')) +
            '======================================'
            ,

            stats.num_full_gc,
            stats.num_inc_gc,
            stats.heap_compactions,
            //stats.current_base,
            format(mem.rss),
            format(mem.heapTotal),
            format(mem.heapUsed)
        );
    });

    this.interval = setInterval(this.gc.bind(this), this.intervalTime);

    utils.invokeCallback(next);
};

pro.gc = function () {
    memwatch.gc();
};

pro.stop = function (force, next) {
    if (this.open || this.app.get('env') === 'production'){
        utils.invokeCallback(next);
        return;
    }
    clearInterval(this.interval);
    utils.invokeCallback(next);
};